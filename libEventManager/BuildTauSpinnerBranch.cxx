/*****************************************************************************
   Name    : BuildTauSpinnerBranch.cxx
   Package : 
   Author  : Elzbieta Richter-Was
   Created : June 2015
   
   DESCRIPTION:
   
  This class is building branch from particles in the event which is used by TauSpinner 
  COPIED from example by T. Przedzinski 

*****************************************************************************/

// Include files

#define BuildTauSpinnerBranch_cxx

#include "BuildTauSpinnerBranch.h"
#include "../libHistoManager/HistoManager.h"

// HepMC include file
#include "HepMC/GenEvent.h"

// Particle class for boosts, angles calculation and rotations
#include "TauSpinner/SimpleParticle.h"

#include <stdio.h>
#include <math.h> 

#include "TLorentzVector.h"

#include <TROOT.h>
#include <TChain.h>
#include <TFile.h>
#include <TMath.h>
#include <TObject.h>
#include <TRandom.h>

using namespace TauSpinner;

BuildTauSpinnerBranch* BuildTauSpinnerBranch::gBuildTauSpinnerBranch = 0;

BuildTauSpinnerBranch* BuildTauSpinnerBranch::getInstance()
{
  if (!gBuildTauSpinnerBranch) gBuildTauSpinnerBranch=new BuildTauSpinnerBranch();
  return gBuildTauSpinnerBranch;
}


const bool  DEBUG = 0;
//CONSTRUCTOR
//----------------------------------------------
BuildTauSpinnerBranch::BuildTauSpinnerBranch()
//----------------------------------------------
{

} 

//DESTRUCTOR
//----------------------------------------------
BuildTauSpinnerBranch::~BuildTauSpinnerBranch()
//----------------------------------------------
{

}

//Initialize
//----------------------------------------------
void BuildTauSpinnerBranch::Initialize(char *filename, int idhist)
//----------------------------------------------
{

  //  Create histograms for this analysis
  CreateHistos(100);

  m_idHist= idhist;
  CreateHistos(m_idHist+1000000);

}

//Finalize
//----------------------------------------------
void BuildTauSpinnerBranch::Finalize()
//----------------------------------------------
{


}

//----------------------------------------------
int BuildTauSpinnerBranch::getZDecayDaughters(HepMC::GenEvent *hepmc, SimpleParticle &X, vector<SimpleParticle> &Z_daughters){
//----------------------------------------------


  // Extract Z decay branch from the event
  HepMC::GenParticle *hX=NULL;

  HepMC::GenEvent::particle_const_iterator  it = hepmc->particles_begin();

  for(; it!=hepmc->particles_end(); ++it) {
    int pdgid = (*it)->pdg_id();
    if( (*it)->end_vertex() ) {
      //      std:: cout << "pdgid=  " << pdgid << "end_vertex size=" <<  (*it)->end_vertex()->particles_out_size() << std::endl;
      if(  pdgid ==23  &&  (*it)->end_vertex()->particles_out_size()>1) {
	hX = *it;	  
      }
      else 
	hX = NULL;
    }
  }
  
  // Boson not found - finished processing the event
  if(!hX) return 1;
  
  //  std::cout << "found Z boson" << std::endl;

  // Fill SimpleParticles from HepMC particles
  X.setPx(hX->momentum().px());
  X.setPy(hX->momentum().py());
  X.setPz(hX->momentum().pz());
  X.setE (hX->momentum().e ());
  X.setPdgid(hX->pdg_id());
    
  // Create list of Z daughters
  vector<SimpleParticle> *buf = getDaughters(hX);
  Z_daughters.clear();
  Z_daughters.insert(Z_daughters.end(),buf->begin(),buf->end());
  
  delete buf;
  
  return 2;
  
}


//----------------------------------------------
/*
  This class is prepared for use with files generated by Pythia8.
  Fills:
  
  'X'              - Heavy particle (W+/-, H+/-, H, Z)
  'tau'            - first tau
  'tau2'           - second tau or nu_tau, if 'X' decays to one tau only
  'tau_daughters'  - daughters of 'tau'
  'tau2_daughters' - daughters of 'tau2' or empty list, if 'tau2' is nu_tau.
  
  Returns:
  1 - no decay to tau found in the event     (finished processing current event)
  2 - decay found and processed correctly.
      Event will continue to be processed with next function call. */
//----------------------------------------------
int BuildTauSpinnerBranch::buildSimpleBranch(HepMC::GenEvent *hepmc, SimpleParticle &X, SimpleParticle &tau, SimpleParticle &tau2, 
                                             vector<SimpleParticle> &tau_daughters, vector<SimpleParticle> &tau2_daughters){
//----------------------------------------------


  // Extract tau branch from the event
  HepMC::GenParticle *hX=NULL, *hTau=NULL, *hTau2=NULL;

  HepMC::GenEvent::particle_const_iterator  it = hepmc->particles_begin();

  for(; it!=hepmc->particles_end(); ++it) {
    int pdgid = (*it)->pdg_id();
    if(   ( abs(pdgid)==37 || pdgid ==25 || abs(pdgid)==24 || pdgid ==23 )
	  &&  (*it)->end_vertex()->particles_out_size()>1 
	  &&  (*(*it)->end_vertex()->particles_out_const_begin())->pdg_id()!=pdgid ) {
      hX = *it;
	  
      // Get daughters of X
      HepMC::GenVertex   *x_daughters = (*it)->end_vertex();
      
      // tau should be the 1st daughter of X
      HepMC::GenParticle *first_daughter  =     *x_daughters->particles_out_const_begin();
      HepMC::GenParticle *second_daughter = *(++(x_daughters->particles_out_const_begin()));
      
      // ignore all self-decays
      while(first_daughter->end_vertex()) {
	HepMC::GenParticle *buf = (*first_daughter->end_vertex()->particles_out_const_begin());
	if(buf->pdg_id()==first_daughter->pdg_id()) first_daughter = buf;
	else break;
      }
      while(second_daughter->end_vertex()){
	HepMC::GenParticle *buf = (*second_daughter->end_vertex()->particles_out_const_begin());
	if(buf->pdg_id()==second_daughter->pdg_id()) second_daughter = buf;
	else break;
      }
      // Check if it is tau and if it has decay products
      if( abs(first_daughter->pdg_id())==15 && first_daughter->end_vertex()!=NULL){
	hTau  = first_daughter;
	hTau2 = second_daughter;
	++it;
	break;
      }
      else if( abs(second_daughter->pdg_id())==15 && second_daughter->end_vertex()!=NULL){
	hTau  = second_daughter;
	hTau2 = first_daughter;
	++it;
	break;
      }
      else 
	hX = NULL;
    }
  }

  // Boson not found - finished processing the event
  if(!hX) return 1;
  
  if(!hTau || !hTau2) {
    cout<<"ERROR: Something is wrong with event record."<<endl;
    exit(-1);
  }
  
  // Fill SimpleParticles from HepMC particles
  X.setPx(hX->momentum().px());
  X.setPy(hX->momentum().py());
  X.setPz(hX->momentum().pz());
  X.setE (hX->momentum().e ());
  X.setPdgid(hX->pdg_id());
  
  tau.setPx(hTau->momentum().px());
  tau.setPy(hTau->momentum().py());
  tau.setPz(hTau->momentum().pz());
  tau.setE (hTau->momentum().e ());
  tau.setPdgid(hTau->pdg_id());
  
  tau2.setPx(hTau2->momentum().px());
  tau2.setPy(hTau2->momentum().py());
  tau2.setPz(hTau2->momentum().pz());
  tau2.setE (hTau2->momentum().e ());
  tau2.setPdgid(hTau2->pdg_id());
  
  // Create list of tau daughters
  vector<SimpleParticle> *buf = getDaughters(hTau);
  tau_daughters.clear();
  tau_daughters.insert(tau_daughters.end(),buf->begin(),buf->end());
  
  delete buf;
  
  // Second particle can be 2nd tau. In that case - read its daughters.
  // Otherwise it is nu_tau~
  buf = getDaughters(hTau2);
  tau2_daughters.clear();
  tau2_daughters.insert(tau2_daughters.end(),buf->begin(),buf->end());
  
  delete buf;

  return 2;
  
}

//----------------------------------------------
/** @brief Process HepMC event with events: p1 p2 -> H p3 p4; H -> tau tau
 *  Returns also vector of tau's daughters
 *  Finds appropriate HepMC particles and returns them as SimpleParticle
 *  for TauSpinner
 */
//----------------------------------------------
int BuildTauSpinnerBranch::buildHqBranch(HepMC::GenEvent *evt, 
                                         SimpleParticle &p1, SimpleParticle &p2,  SimpleParticle &X,
                                         SimpleParticle &p3, SimpleParticle &tau, SimpleParticle &tau2, 
                                         vector<SimpleParticle> &tau_daughters, vector<SimpleParticle> &tau2_daughters){
//----------------------------------------------

  // Extract tau branch from the event

    HepMC::GenParticle *boson  = NULL;
    HepMC::GenParticle *beam1  = NULL, *beam2  = NULL;
    HepMC::GenParticle *jet1   = NULL;
    HepMC::GenParticle *tau_h  = NULL, *tau2_h = NULL;

    // Find all particles needed to compute the weight
    bool ok = true;

    ok &= findProdBranchHqq(evt, beam1, beam2);
    ok &= findDecayBranchHq(beam1, boson, jet1);
    ok &= findDecayBranchXtautau(evt, boson, tau_h, tau2_h);

    if( !ok ) return 1;

    // Now fill simple particles
    p1   = GenParticle_to_SimpleParticle(beam1);
    p2   = GenParticle_to_SimpleParticle(beam2);
    X    = GenParticle_to_SimpleParticle(boson);
    p3   = GenParticle_to_SimpleParticle(jet1);
    tau  = GenParticle_to_SimpleParticle(tau_h);
    tau2 = GenParticle_to_SimpleParticle(tau2_h);

  // Create list of tau daughters
  vector<SimpleParticle> *buf = getDaughters(tau_h);
  tau_daughters.clear();
  tau_daughters.insert(tau_daughters.end(),buf->begin(),buf->end());
  
  delete buf;

  buf = getDaughters(tau2_h);
  tau2_daughters.clear();
  tau2_daughters.insert(tau2_daughters.end(),buf->begin(),buf->end());
   
  delete buf;

  return 2;

}

//----------------------------------------------
/** @brief Process HepMC event with events: p1 p2 -> H p3 p4; H -> tau tau
 *  Returns also vector of tau's daughters
 *  Finds appropriate HepMC particles and returns them as SimpleParticle
 *  for TauSpinner
 */
//----------------------------------------------
int BuildTauSpinnerBranch::buildBornBranch(HepMC::GenEvent *evt, 
                                         SimpleParticle &p1, SimpleParticle &p2,  SimpleParticle &X,
                                         SimpleParticle &tau, SimpleParticle &tau2, 
                                         vector<SimpleParticle> &tau_daughters, vector<SimpleParticle> &tau2_daughters){
//----------------------------------------------

  // Extract tau branch from the event

    HepMC::GenParticle *boson  = NULL;
    HepMC::GenParticle *beam1  = NULL, *beam2  = NULL;
    HepMC::GenParticle *tau_h  = NULL, *tau2_h = NULL;

    // Find all particles needed to compute the weight
    bool ok = true;

    ok &= findProdBranchBorn(evt, beam1, beam2);
    // accept even if  boson not found
    findDecayBranchBorn(beam1, boson);
    if(boson)
      ok &= findDecayBranchXtautau(evt, boson, tau_h, tau2_h);
    else
      ok &= findDecayBranchXtautau(evt, beam1, tau_h, tau2_h); 

    if( !ok ) 
      cout << "ERROR buildBornBranch: branch not found" << endl;

    if( !ok ) return 1;

    // Now fill simple particles
    p1   = GenParticle_to_SimpleParticle(beam1);
    p2   = GenParticle_to_SimpleParticle(beam2);
    tau  = GenParticle_to_SimpleParticle(tau_h);
    tau2 = GenParticle_to_SimpleParticle(tau2_h);
    if(boson) 
    X    = GenParticle_to_SimpleParticle(boson);
    else {
      X.setPx (tau.px()+tau2.px());
      X.setPy (tau.py()+tau2.py());
      X.setPz (tau.pz()+tau2.pz());
      X.setE (tau.e()+tau2.e());
      X.setPdgid ( 0);
    }

  // Create list of tau daughters
  vector<SimpleParticle> *buf = getDaughters(tau_h);
  tau_daughters.clear();
  tau_daughters.insert(tau_daughters.end(),buf->begin(),buf->end());
  
  delete buf;

  buf = getDaughters(tau2_h);
  tau2_daughters.clear();
  tau2_daughters.insert(tau2_daughters.end(),buf->begin(),buf->end());
   
  delete buf;

  return 2;

}

//----------------------------------------------
/** @brief Process HepMC event with events: p1 p2 -> tau tau p3 p4
 *  Returns also vector of tau's daughters
 *  Finds appropriate HepMC particles and returns them as SimpleParticle
 *  for TauSpinner
 */
//----------------------------------------------
int BuildTauSpinnerBranch::buildVBFBranch(HepMC::GenEvent *evt, 
                                         SimpleParticle &p1, SimpleParticle &p2,  SimpleParticle &X,
                                         SimpleParticle &p3, SimpleParticle &p4, SimpleParticle &tau, SimpleParticle &tau2, 
                                         vector<SimpleParticle> &tau_daughters, vector<SimpleParticle> &tau2_daughters){
//----------------------------------------------

  // Extract tau branch from the event

    HepMC::GenParticle *boson  = NULL;
    HepMC::GenParticle *beam1  = NULL, *beam2  = NULL;
    HepMC::GenParticle *jet1   = NULL, *jet2   = NULL;
    HepMC::GenParticle *tau_h  = NULL, *tau2_h = NULL;

    // Find all particles needed to compute the weight
    bool ok = true;

    ok &= findProdBranchHqq(evt, beam1, beam2);
    // accept even if  boson not found
    ok &= findDecayBranchHqq( evt, beam1, boson, jet1, jet2);
    if(boson)
      ok &= findDecayBranchXtautau(evt, boson, tau_h, tau2_h);
    else
      ok &= findDecayBranchXtautau(evt, beam1, tau_h, tau2_h); 

    if( !ok ) return 1;

    // Now fill simple particles
    p1   = GenParticle_to_SimpleParticle(beam1);
    p2   = GenParticle_to_SimpleParticle(beam2);
    tau  = GenParticle_to_SimpleParticle(tau_h);
    tau2 = GenParticle_to_SimpleParticle(tau2_h);
    // random assigning of the jet pdgid and order
    double rnd = random.Rndm();
    if( rnd < 0.5){
      p3   = GenParticle_to_SimpleParticle(jet1);
      p4   = GenParticle_to_SimpleParticle(jet2);
    } else {
      p3   = GenParticle_to_SimpleParticle(jet2);
      p4   = GenParticle_to_SimpleParticle(jet1);
    }
    if(boson) 
    X    = GenParticle_to_SimpleParticle(boson);
    else {
      X.setPx (tau.px()+tau2.px());
      X.setPy (tau.py()+tau2.py());
      X.setPz (tau.pz()+tau2.pz());
      X.setE (tau.e()+tau2.e());
      X.setPdgid ( 0);
    }

  // Create list of tau daughters
  vector<SimpleParticle> *buf = getDaughters(tau_h);
  tau_daughters.clear();
  tau_daughters.insert(tau_daughters.end(),buf->begin(),buf->end());
  
  delete buf;

  buf = getDaughters(tau2_h);
  tau2_daughters.clear();
  tau2_daughters.insert(tau2_daughters.end(),buf->begin(),buf->end());
   
  delete buf;

  return 2;

}

//----------------------------------------------
/** @brief Process HepMC event with events: p1 p2 -> H p3; H -> tau tau
 *  Returns also vector of tau's daughters
 *  Finds appropriate HepMC particles and returns them as SimpleParticle
 *  for TauSpinner
 */
//----------------------------------------------
int BuildTauSpinnerBranch::readHqBranch(HepMC::IO_GenEvent &input_file, 
                                         SimpleParticle &p1, SimpleParticle &p2,  SimpleParticle &X,
                                         SimpleParticle &p3, SimpleParticle &tau, SimpleParticle &tau2, 
                                         vector<SimpleParticle> &tau_daughters, vector<SimpleParticle> &tau2_daughters){
//----------------------------------------------

    HepMC::GenParticle *boson  = NULL;
    HepMC::GenParticle *beam1  = NULL, *beam2  = NULL;
    HepMC::GenParticle *jet1   = NULL;
    HepMC::GenParticle *tau_h  = NULL, *tau2_h = NULL;

    // Get next event from file
    HepMC::GenEvent *evt = new HepMC::GenEvent();

    input_file.fill_next_event(evt);

    if( input_file.rdstate() ) {
        delete evt;
        return 1;
    }

    // Find all particles needed to compute the weight
    bool ok = true;

    ok &= findProdBranchHq(evt, beam1, beam2);
    ok &= findDecayBranchHq(beam1, boson, jet1);
    ok &= findDecayBranchXtautau(evt, boson, tau_h, tau2_h);

    if( !ok ) {
        evt->print();
        delete evt;
        return 1;
    }

    // Now fill simple particles
    p1   = GenParticle_to_SimpleParticle(beam1);
    p2   = GenParticle_to_SimpleParticle(beam2);
    X    = GenParticle_to_SimpleParticle(boson);
    p3   = GenParticle_to_SimpleParticle(jet1);
    tau  = GenParticle_to_SimpleParticle(tau_h);
    tau2 = GenParticle_to_SimpleParticle(tau2_h);

  // Create list of tau daughters
  vector<SimpleParticle> *buf = getDaughters(tau_h);
  tau_daughters.clear();
  tau_daughters.insert(tau_daughters.end(),buf->begin(),buf->end());
  
  delete buf;

  buf = getDaughters(tau2_h);
  tau2_daughters.clear();
  tau2_daughters.insert(tau2_daughters.end(),buf->begin(),buf->end());
   
  delete buf;

    delete evt;
    return 0;
}


//----------------------------------------------
/** @brief Process HepMC event with events: p1 p2 -> H p3; H -> tau tau
 *  Returns also vector of tau's daughters
 *  Finds appropriate HepMC particles and returns them as SimpleParticle
 *  for TauSpinner
 */
//----------------------------------------------
int BuildTauSpinnerBranch::readBornBranch(HepMC::IO_GenEvent &input_file, 
                                         SimpleParticle &p1, SimpleParticle &p2,  SimpleParticle &X,
                                         SimpleParticle &tau, SimpleParticle &tau2, 
                                         vector<SimpleParticle> &tau_daughters, vector<SimpleParticle> &tau2_daughters){
//----------------------------------------------

    HepMC::GenParticle *boson  = NULL;
    HepMC::GenParticle *beam1  = NULL, *beam2  = NULL;
    HepMC::GenParticle *tau_h  = NULL, *tau2_h = NULL;

    // Get next event from file
    HepMC::GenEvent *evt = new HepMC::GenEvent();

    input_file.fill_next_event(evt);

    if( input_file.rdstate() ) {
        delete evt;
        return 1;
    }

    // Find all particles needed to compute the weight
    bool ok = true;

    ok &= findProdBranchBorn(evt, beam1, beam2);
    findDecayBranchBorn(beam1, boson);
    ok &= findDecayBranchXtautau(evt, boson, tau_h, tau2_h);

    if( !ok ) {
        evt->print();
        delete evt;
        return 1;
    }

    // Now fill simple particles
    p1   = GenParticle_to_SimpleParticle(beam1);
    p2   = GenParticle_to_SimpleParticle(beam2);
    tau  = GenParticle_to_SimpleParticle(tau_h);
    tau2 = GenParticle_to_SimpleParticle(tau2_h);
    if(boson) 
      X    = GenParticle_to_SimpleParticle(boson);
    else {
      X.setPx (tau.px()+tau2.px());
      X.setPy (tau.py()+tau2.py());
      X.setPz (tau.pz()+tau2.pz());
      X.setE (tau.e()+tau2.e());
      X.setPdgid ( 0);
    }

  // Create list of tau daughters
  vector<SimpleParticle> *buf = getDaughters(tau_h);
  tau_daughters.clear();
  tau_daughters.insert(tau_daughters.end(),buf->begin(),buf->end());
  
  delete buf;

  buf = getDaughters(tau2_h);
  tau2_daughters.clear();
  tau2_daughters.insert(tau2_daughters.end(),buf->begin(),buf->end());
   
  delete buf;

    delete evt;
    return 0;
}


//----------------------------------------------
/** @brief Process HepMC event with events: p1 p2 -> H p3 p4; H -> tau tau
 *  Returns also vector of tau's daughters
 *  Finds appropriate HepMC particles and returns them as SimpleParticle
 *  for TauSpinner
 */
//----------------------------------------------
int BuildTauSpinnerBranch::readVBFBranch(HepMC::IO_GenEvent &input_file, 
                                         SimpleParticle &p1, SimpleParticle &p2,  SimpleParticle &X,
                                         SimpleParticle &p3, SimpleParticle &p4, SimpleParticle &tau, SimpleParticle &tau2, 
                                         vector<SimpleParticle> &tau_daughters, vector<SimpleParticle> &tau2_daughters){
//----------------------------------------------

    HepMC::GenParticle *boson  = NULL;
    HepMC::GenParticle *beam1  = NULL, *beam2  = NULL;
    HepMC::GenParticle *jet1   = NULL, *jet2   = NULL;
    HepMC::GenParticle *tau_h  = NULL, *tau2_h = NULL;

    // Get next event from file
    HepMC::GenEvent *evt = new HepMC::GenEvent();

    input_file.fill_next_event(evt);

    if( input_file.rdstate() ) {
        delete evt;
        return 1;
    }

    // Find all particles needed to compute the weight
    bool ok = true;

    ok &= findProdBranchHqq(evt, beam1, beam2);
    ok &= findDecayBranchHqq(evt, beam1, boson, jet1, jet2);
    if(boson)
      ok &= findDecayBranchXtautau(evt,boson, tau_h, tau2_h);
    else
      ok &= findDecayBranchXtautau(evt,beam1, tau_h, tau2_h); 

    if( !ok ) {
        evt->print();
        delete evt;
        return 1;
    }
    
    // Now fill simple particles
    p1   = GenParticle_to_SimpleParticle(beam1);
    p2   = GenParticle_to_SimpleParticle(beam2);
    p3   = GenParticle_to_SimpleParticle(jet1);
    p4   = GenParticle_to_SimpleParticle(jet2);
    tau  = GenParticle_to_SimpleParticle(tau_h);
    tau2 = GenParticle_to_SimpleParticle(tau2_h);
    if(boson) 
      X  = GenParticle_to_SimpleParticle(boson);     
    else {
      X.setPx (tau.px()+tau2.px());
      X.setPy (tau.py()+tau2.py());
      X.setPz (tau.pz()+tau2.pz());
      X.setE (tau.e()+tau2.e());
      X.setPdgid ( 0);
    }
    
    // Create list of tau daughters
    vector<SimpleParticle> *buf = getDaughters(tau_h);
    tau_daughters.clear();
    tau_daughters.insert(tau_daughters.end(),buf->begin(),buf->end());
    
    delete buf;
    
    buf = getDaughters(tau2_h);
    tau2_daughters.clear();
    tau2_daughters.insert(tau2_daughters.end(),buf->begin(),buf->end());
    
    delete buf;

    delete evt;
    return 0;
}


//----------------------------------------------
/*
  This class is prepared for use with files generated by Pythia8.
  Fills:
  
  'X'              - Heavy particle (W+/-, H+/-, H, Z)
  'tau'            - first tau
  'tau2'           - second tau or nu_tau, if 'X' decays to one tau only
  'tau_daughters'  - daughters of 'tau'
  'tau2_daughters' - daughters of 'tau2' or empty list, if 'tau2' is nu_tau.
  
  Returns:
  1 - no decay to tau found in the event     (finished processing current event)
  2 - decay found and processed correctly.
      Event will continue to be processed with next function call. */
//----------------------------------------------
int BuildTauSpinnerBranch::readSimpleBranch(HepMC::IO_GenEvent &input_file, SimpleParticle &X, SimpleParticle &tau, SimpleParticle &tau2, 
                                            vector<SimpleParticle> &tau_daughters, vector<SimpleParticle> &tau2_daughters){
//----------------------------------------------

  HepMC::GenEvent  *hepmc = new HepMC::GenEvent();

  // Read (parsed i.e. consiting of W and tau decay vertices only) event from input file
  input_file.fill_next_event(hepmc);

  // Extract tau branch from the event
  HepMC::GenParticle *hX=NULL, *hTau=NULL, *hTau2=NULL;

  HepMC::GenEvent::particle_const_iterator  it = hepmc->particles_begin();

  for(; it!=hepmc->particles_end(); ++it) {
    int pdgid = (*it)->pdg_id();
    if(   ( abs(pdgid)==37 || pdgid ==25 || abs(pdgid)==24 || pdgid ==23 )
	  &&  (*it)->end_vertex()->particles_out_size()>1 
	  &&  (*(*it)->end_vertex()->particles_out_const_begin())->pdg_id()!=pdgid ) {
      hX = *it;
	  
      // Get daughters of X
      HepMC::GenVertex   *x_daughters = (*it)->end_vertex();
      
      // tau should be the 1st daughter of X
      HepMC::GenParticle *first_daughter  =     *x_daughters->particles_out_const_begin();
      HepMC::GenParticle *second_daughter = *(++(x_daughters->particles_out_const_begin()));
      
      // ignore all self-decays
      while(first_daughter->end_vertex()) {
	HepMC::GenParticle *buf = (*first_daughter->end_vertex()->particles_out_const_begin());
	if(buf->pdg_id()==first_daughter->pdg_id()) first_daughter = buf;
	else break;
      }
      while(second_daughter->end_vertex()){
	HepMC::GenParticle *buf = (*second_daughter->end_vertex()->particles_out_const_begin());
	if(buf->pdg_id()==second_daughter->pdg_id()) second_daughter = buf;
	else break;
      }
      
      // Check if it is tau and if it has decay products
      if( abs(first_daughter->pdg_id())==15 && first_daughter->end_vertex()!=NULL){
	hTau  = first_daughter;
	hTau2 = second_daughter;
	++it;
	break;
      }
      else if( abs(second_daughter->pdg_id())==15 && second_daughter->end_vertex()!=NULL){
	hTau  = second_daughter;
	hTau2 = first_daughter;
	++it;
	break;
      }
      else 
	hX = NULL;
    }
  }
  
  // Boson not found - finished processing the event
  if(!hX) return 1;
  
  if(!hTau || !hTau2) {
    cout<<"ERROR: Something is wrong with event record."<<endl;
    exit(-1);
  }
  
  // Fill SimpleParticles from HepMC particles
  X.setPx(hX->momentum().px());
  X.setPy(hX->momentum().py());
  X.setPz(hX->momentum().pz());
  X.setE (hX->momentum().e ());
  X.setPdgid(hX->pdg_id());
  
  tau.setPx(hTau->momentum().px());
  tau.setPy(hTau->momentum().py());
  tau.setPz(hTau->momentum().pz());
  tau.setE (hTau->momentum().e ());
  tau.setPdgid(hTau->pdg_id());
  
  tau2.setPx(hTau2->momentum().px());
  tau2.setPy(hTau2->momentum().py());
  tau2.setPz(hTau2->momentum().pz());
  tau2.setE (hTau2->momentum().e ());
  tau2.setPdgid(hTau2->pdg_id());
  
  // Create list of tau daughters
  vector<SimpleParticle> *buf = getDaughters(hTau);
  tau_daughters.clear();
  tau_daughters.insert(tau_daughters.end(),buf->begin(),buf->end());
  
  delete buf;
  
  // Second particle can be 2nd tau. In that case - read its daughters.
  // Otherwise it is nu_tau~
  buf = getDaughters(hTau2);
  tau2_daughters.clear();
  tau2_daughters.insert(tau2_daughters.end(),buf->begin(),buf->end());
  
  delete buf;

  return 2;
  
}

//----------------------------------------------------------------------------------------------
/*
  Search for qqV production branch, as beams accepted partons (quarks or gluons) which have end vertex present
  particles are found (pdgid not checked)
 */
//----------------------------------------------------------------------------------------------

bool BuildTauSpinnerBranch::findProdBranchHqq(HepMC::GenEvent *evt, HepMC::GenParticle *&beam1, HepMC::GenParticle *&beam2) {
    if( !evt ) return false;

    for(HepMC::GenEvent::particle_const_iterator it = evt->particles_begin();
                                                 it!= evt->particles_end();
                                               ++it) {
        if(!(*it)->end_vertex()) continue;

        int pdg  = abs( (*it)->pdg_id() );
        int pdg2 = (*(*it)->end_vertex()->particles_out_const_begin())->pdg_id();

        if( ((pdg< 7 && pdg>0) || pdg==21) && (pdg2 != 0 ) ) {
            if(!beam1) beam1 = (*it);
            else {
                beam2 = (*it);
                break;
            }
        }
    }
    if( beam1 && beam2 ) 
      if(DEBUG) std::cout << "findProdBranchHqq: beams= " << beam1->pdg_id() << " " << beam2->pdg_id() << std::endl;

    if( !beam1 || !beam2 ) {
        cout << "ERROR findProdBranchHqq: Beams not found" << endl;
        return false;
    }
    return true;
}

//----------------------------------------------------------------------------------------------
/*
  Search for Born production branch, as beams accepted partons (quarks or gluons) which have end vertex present
 */
//----------------------------------------------------------------------------------------------

bool BuildTauSpinnerBranch::findProdBranchBorn(HepMC::GenEvent *evt, HepMC::GenParticle *&beam1, HepMC::GenParticle *&beam2) {
    if( !evt ) return false;

    for(HepMC::GenEvent::particle_const_iterator it = evt->particles_begin();
                                                 it!= evt->particles_end();
                                               ++it) {
        if(!(*it)->end_vertex()) continue;

        int pdg  = abs( (*it)->pdg_id() );
        int pdg2 = (*(*it)->end_vertex()->particles_out_const_begin())->pdg_id();

        if( ((pdg< 7 && pdg>0) || pdg==21) && ( pdg2 != 0) ) {
            if(!beam1) beam1 = (*it);
            else {
                beam2 = (*it);
                break;
            }
        }
    }

    if( !beam1 || !beam2 ) {
        cout << "ERROR findProdBranchBorn: Beams not found" << endl;
        return false;
    }
    return true;
}


//----------------------------------------------------------------------------------------------
/*
  Search for qH production branch, defined by vertex where X of pdg_id = 25 is outgoing and two incoming 
  particles are found (pdgid not checked)
 */
//----------------------------------------------------------------------------------------------

bool BuildTauSpinnerBranch::findProdBranchHq(HepMC::GenEvent *evt, HepMC::GenParticle *&beam1, HepMC::GenParticle *&beam2) {
    if( !evt ) return false;

    for(HepMC::GenEvent::particle_const_iterator it = evt->particles_begin();
                                                 it!= evt->particles_end();
                                               ++it) {
        if(!(*it)->end_vertex()) continue;

        int pdg  = abs( (*it)->pdg_id() );
        int pdg2 = (*(*it)->end_vertex()->particles_out_const_begin())->pdg_id();

        if( ((pdg< 7 && pdg>0) || pdg==21) && (pdg2==25 || pdg2==23) ) {
            if(!beam1) beam1 = (*it);
            else {
                beam2 = (*it);
                break;
            }
        }
    }

    if( !beam1 || !beam2 ) {
        cout << "ERROR findProdBranchHq: Beams not found" << endl;
        return false;
    }
    return true;
}

//----------------------------------------------------------------------------------------------
/*
  Search for Hqq decay branch, defined by vertex where X of pdg_id = 25 and two outgoing particles
  are found (pdgid not checked)
 */
//----------------------------------------------------------------------------------------------

bool BuildTauSpinnerBranch::findDecayBranchHqq(HepMC::GenEvent *evt, HepMC::GenParticle *mother, HepMC::GenParticle *&X, HepMC::GenParticle *&jet1, HepMC::GenParticle *&jet2) {
    if( !mother ) return false;

    if(DEBUG) std::cout << "findDecayBranchHqq from mother " <<  mother->pdg_id() << std::endl;

    for(HepMC::GenVertex::particles_out_const_iterator it  = mother->end_vertex()->particles_out_const_begin();
                                                       it != mother->end_vertex()->particles_out_const_end();
                                                     ++it) {
      if(DEBUG) std::cout << "findDecayBranchHqq " <<  (*it)->pdg_id() << std::endl;

      // as X we can notify presence of the Higgs only, in the VBF production in some cases
      // both Z and W are in the event record as well.
      if( (*it)->pdg_id() == 25 ) X = *it;
      else if( abs((*it)->pdg_id()) == 15 || abs((*it)->pdg_id()) == 24 || abs((*it)->pdg_id()) == 23 ) continue;
      else {
	if     (!jet1 && ( abs((*it)->pdg_id()) < 7 || (*it)->pdg_id() == 21 ) ) jet1 = (*it);
	else if(!jet2 && ( abs((*it)->pdg_id()) < 7 || (*it)->pdg_id() == 21 ) ) jet2 = (*it);
	else if( abs((*it)->pdg_id()) < 7 || (*it)->pdg_id() == 21 ) {
	  cout << "ERROR: more than 2 jets?" << endl;
	  return false;
	}
      }
    }

    if(!jet1 && !jet2){

      for(HepMC::GenEvent::particle_const_iterator it = evt->particles_begin();
                                                 it!= evt->particles_end();
                                               ++it) {

	//check if at all Higgs present in the event record
        if( (*it)->pdg_id() == 25 ) X = *it;

        if( (*it)->end_vertex()) continue;

        int pdg  = abs( (*it)->pdg_id() );

        if( (pdg< 7 && pdg>0) || pdg==21  ) {
            if(!jet1) jet1 = (*it);
            else {
                jet2 = (*it);
                break;
            }
        }
      }
    }

    if(DEBUG  && jet1) std::cout << "findDecayBranchHqq: jet1 " << jet1->pdg_id() << " " << jet1->momentum().px() << std::endl;
    if(DEBUG  && jet2) std::cout << "findDecayBranchHqq: jet2 " << jet2->pdg_id() << " " << jet2->momentum().px() << std::endl;

    if( !jet1 || !jet2 ) {
        cout << "ERROR findDecayBranchHqq: X or jets not found" << endl;
        return false;
    }

    return true;
}

//----------------------------------------------------------------------------------------------
/*
  Search for Hqq decay branch, defined by vertex where X of pdg_id = 25 and one outgoing particles
  are found (pdgid not checked)
 */
//----------------------------------------------------------------------------------------------

bool BuildTauSpinnerBranch::findDecayBranchHq(HepMC::GenParticle *mother, HepMC::GenParticle *&X, HepMC::GenParticle *&jet) {
    if( !mother ) return false;

    for(HepMC::GenVertex::particles_out_const_iterator it  = mother->end_vertex()->particles_out_const_begin();
                                                       it != mother->end_vertex()->particles_out_const_end();
                                                     ++it) {
      if( (*it)->pdg_id() == 25 ||  (*it)->pdg_id() == 23  ||  abs((*it)->pdg_id()) == 24 ) X = *it;
        else {
            if     (!jet) jet = (*it);
            else {
                cout << "ERROR: more than 1 jet?" << endl;
                return false;
            }
        }
    }

    if( !X || !jet ) {
        cout << "ERROR findDecayBranchHq: X or jet not found" << endl;
        return false;
    }

    return true;
}

//----------------------------------------------------------------------------------------------
/*
  Search for Born decay branch, defined by vertex where X of pdg_id = 25, 23 is found
 */
//----------------------------------------------------------------------------------------------

bool BuildTauSpinnerBranch::findDecayBranchBorn(HepMC::GenParticle *mother, HepMC::GenParticle *&X) {
    if( !mother ) return false;

    for(HepMC::GenVertex::particles_out_const_iterator it  = mother->end_vertex()->particles_out_const_begin();
                                                       it != mother->end_vertex()->particles_out_const_end();
                                                     ++it) {
        if( (*it)->pdg_id() == 25 ) X = *it;
    }

    /*
    if(DEBUG) {
      if( !X ) {
        cout << "ERROR findDecayBranchBorn: X not found" << endl;
	return false;
      }
    }
    */

    return true;
}

//----------------------------------------------------------------------------------------------
/*
  Search for tau pair from particle X, defined by vertex where tau is particle of pdg_id = 15,
  and tau2 is particle from the same decay vertex (pdgid not checked)
 */
//----------------------------------------------------------------------------------------------
bool BuildTauSpinnerBranch::findDecayBranchXtautau(HepMC::GenEvent *evt, HepMC::GenParticle *X, HepMC::GenParticle *&tau, HepMC::GenParticle *&tau2) {

  /*  
    if( !X ) return false;

    while(true) {
        if( !X->end_vertex() ) return false;
        HepMC::GenParticle *p = *X->end_vertex()->particles_out_const_begin();
        if( p->pdg_id() == X->pdg_id() ) X = p;
        else break;
    }

    for(HepMC::GenVertex::particles_out_const_iterator it  = X->end_vertex()->particles_out_const_begin();
                                                       it != X->end_vertex()->particles_out_const_end();
                                                     ++it) {
        if( abs((*it)->pdg_id()) == 15 ) {
            if(!tau) tau = *it;
            else {
                tau2 = *it;
                break;
            }
        }
    }

    if(!tau && !tau2) {
  */
  if( !evt ) return false;
      
  // here loop over all particles until tau pair found, common prodction vertex not required
  for(HepMC::GenEvent::particle_const_iterator it = evt->particles_begin();
      it!= evt->particles_end();
      ++it) {  
    if( abs((*it)->pdg_id()) == 15 || abs((*it)->pdg_id()) == 16 ) {
      if (!tau) { 
	tau = *it;
      } else {
	tau2 = *it;
	break;           
      }
    }
  }

  if( !tau || !tau2 ) {
    cout << "ERROR findDecayBranchXtautau: tau pair not found" << endl;
    return false;
  }
  return true;
}



/*******************************************************************************
  Get daughters of HepMC::GenParticle
  Recursively searches for final-state daughters of 'x'
*******************************************************************************/
vector<SimpleParticle> *BuildTauSpinnerBranch::getDaughters(HepMC::GenParticle *x) {

  vector<SimpleParticle> *daughters = new vector<SimpleParticle>();
  if(!x->end_vertex()) return daughters;

  // Check decay products of 'x'
  for(HepMC::GenVertex::particles_out_const_iterator p = x->end_vertex()->particles_out_const_begin(); p!=x->end_vertex()->particles_out_const_end(); ++p)
  {
    HepMC::GenParticle *pp = *p;
    HepMC::FourVector   mm = pp->momentum();

    // If the daughter of 'x' has its end vertex - recursively read
    // all of its daughters.
    if( pp->end_vertex() && pp->pdg_id()!=111)
    {
      vector<SimpleParticle> *sub_daughters = getDaughters(pp);
      daughters->insert(daughters->end(),sub_daughters->begin(),sub_daughters->end());
      
      delete sub_daughters;
    }
    // Otherwise - add this particle to the list of daughters.
    else
    {
      SimpleParticle tp( mm.px(), mm.py(), mm.pz(), mm.e(), pp->pdg_id() );
      daughters->push_back(tp);
    }
  }

  return daughters;
}

/*******************************************************************************
  Get direct daughters of HepMC::GenParticle
*******************************************************************************/
vector<SimpleParticle> *BuildTauSpinnerBranch::getDirectDaughters(HepMC::GenParticle *x) {

  vector<SimpleParticle> *daughters = new vector<SimpleParticle>();
  if(!x->end_vertex()) return daughters;

  // Check decay products of 'x'
  for(HepMC::GenVertex::particles_out_const_iterator p = x->end_vertex()->particles_out_const_begin(); p!=x->end_vertex()->particles_out_const_end(); ++p)
  {
    HepMC::GenParticle *pp = *p;
    HepMC::FourVector   mm = pp->momentum();

    SimpleParticle tp( mm.px(), mm.py(), mm.pz(), mm.e(), pp->pdg_id() );
    daughters->push_back(tp);
  }

  return daughters;
}

//----------------------------------------------
/* Get decay channel  (sequence of daughters matter)
   Returns:
   -1 - unrecognized (unsupported) channel
    0 - no daughters
    1 - electron (tau -> nu_tau nue e [+gamma])
    2 - muon     (tau -> nu_tau nu_mu mu [+gamma])
    3 - pion     (tau -> nu_tau pi)
    4 - rho      (tau -> nu_tau pi0 pi) */
//----------------------------------------------
int  BuildTauSpinnerBranch::get_decay_channel(vector<SimpleParticle> &tau_daughters)
{
  int size = tau_daughters.size();
  
  if(size==0) return 0;

  int id[4] = { 0 };
  if(size>0) id[0] = abs(tau_daughters[0].pdgid());
  if(size>1) id[1] = abs(tau_daughters[1].pdgid());
  if(size>2) id[2] = abs(tau_daughters[2].pdgid());
  if(size>3) id[3] = abs(tau_daughters[3].pdgid());

  // nu_tau pi
  if(size==2 && id[1]==211) return 3;
  
  // nu_tau rho
  if(size==2 && id[1]==213) return 4;
  
  if(size==3)
  {
    // nu_tau e nu_e 
    if(id[1]==11) return 1;
    
    // nu_tau mu nu_mu 
    if(id[1]==13) return 2;
    
    // nu_tau pi0 pi (without intermediate rho)
    if( (id[1]==111 && id[2]==211) ||
        (id[1]==211 && id[2]==111)    ) return 4;
  }
  
  if(size==4 && id[3]==22)
  {
    // nu tau e nu_e gamma
    if(id[1]==11) return 1;
    
    // nu tau mu nu_mu gamma
    if(id[1]==13) return 2;
  }
  
  return -1;
}
//----------------------------------------------------
/*  Calculates cosThetaStar, as introduced for asymmetry definition
    in the ActaPhysPolon 
 */
//----------------------------------------------------
double  BuildTauSpinnerBranch::get_costheta(SimpleParticle &pp1, SimpleParticle &pp2)
{
// tau+ and tau- in lab frame

  double costheta1 =  pp1.pz()/sqrt(pp1.px()*pp1.px()+pp1.py()*pp1.py()+pp1.pz()*pp1.pz());

  double costheta2 = -pp2.pz()/sqrt(pp2.px()*pp2.px()+pp2.py()*pp2.py()+pp2.pz()*pp2.pz());

  double sintheta1 = sqrt(1-costheta1*costheta1);
  double sintheta2 = sqrt(1-costheta2*costheta2);

  double costhetaStar = (costheta1*sintheta2 + costheta2*sintheta1) / (sintheta1 + sintheta2);

  return costhetaStar;
}

//----------------------------------------------------
SimpleParticle BuildTauSpinnerBranch::GenParticle_to_SimpleParticle(HepMC::GenParticle *p) {
    return SimpleParticle( p->momentum().px(), p->momentum().py(), p->momentum().pz(), p->momentum().e(), p->pdg_id() );
}


//----------------------------------------------------
//
void BuildTauSpinnerBranch::CreateHistos( int idhist)  {

  
  HistoManager *hmg  = HistoManager::getInstance();

  Text_t namehist[500];

  //monitor cut flow
  if(  idhist == m_idHist+1000000 ){
    sprintf(namehist,"hist%.2d",idhist);  
    hmg->addTH1F(namehist,    "  cut flow counter (events) ", 50  ,   0.0  ,  50.0); 
  }

}

